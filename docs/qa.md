/**
 * @file: qa.md
 * @description: Вопросы по архитектуре проекта
 * @created: 2023.10.15
 */

# Архитектурные вопросы (React Native)

1. **Выбор state-менеджмента**
   - Почему Redux Toolkit вместо Zustand/MobX?
     *Ответ:* Redux Toolkit выбран из-за интеграции с типизацией TypeScript, встроенной обработки иммутабельности через Immer, и упрощённого создания асинхронных операций через createAsyncThunk. Zustand проще для мелких проектов, но Redux лучше масштабируется для сложной логики таймеров с перекрёстными зависимостями.
   - Как обрабатывать сложные состояния таймера с асинхронными операциями?
     *Ответ:* Используйте slice-редюсеры с асинхронными thunk'ами для управления жизненным циклом таймера (start/pause/reset). Для длительных операций применяйте middleware like redux-offline для отложенных действий и обработки ошибок сети.

2. **Локальное хранилище**
   - Как объединить AsyncStorage и SQLite для разных типов данных?
     *Ответ:* AsyncStorage для простых данных (настройки темы, флаги), SQLite — для структурированных (история таймеров, пользовательские данные). Используйте библиотеку WatermelonDB для reactive-подхода или react-native-sqlite-storage с кастомными адаптерами.
   - Как обрабатывать миграции схемы SQLite при обновлении приложения?
     *Ответ:* Реализуйте версионирование схемы через параметр `version` в SQLite-подключении. При увеличении версии запускайте SQL-скрипты миграций, используя транзакции для безопасного обновления структуры.

3. **Аудио-библиотека**
   - Как обеспечить воспроизведение звука в фоновом режиме через react-native-sound?
     *Ответ:* react-native-sound не поддерживает фоновый режим на iOS. Используйте react-native-track-player — он предоставляет системные уведомления, обработку медиа-кнопок и фоновое воспроизведение через native-модули.
   - Как обрабатывать разные форматы аудио-файлов на разных платформах?
     *Ответ:* На iOS поддержка зависит от AVFoundation (предпочитайте .mp3/.m4a), на Android — через ExoPlayer (.wav/.ogg). Конвертируйте файлы в универсальный формат (.mp3) при загрузке через ffmpeg-kit.

4. **Темизация интерфейса**
   - Как реализовать переключение светлой/темной темы без перезагрузки?
     *Ответ:* Храните активную тему в Context API с memoization. Оберните приложение в ThemeProvider, используя StyleSheet.create() для динамических стилей. Переключайте тему через dispatch без полной перемонтировки.
   - Где хранить конфигурацию темы (Redux Store vs AsyncStorage)?
     *Ответ:* В AsyncStorage для persistence между сессиями, плюс в Redux Store для реактивного обновления UI. Синхронизируйте при старте через thunk, поддерживая единый источник истины.

5. **Безопасность данных**
   - Достаточно ли react-native-sensitive-info для защиты данных в AsyncStorage?
     *Ответ:* Нет. react-native-sensitive-info шифрует данные, но уязвим к root/jailbreak. Для критичных данных применяйте дополнительное шифрование через react-native-fast-crypto (AES-256) и храните ключи в системных хранилищах (Android KeyStore/iOS Keychain).
   - Как предотвратить дамп памяти с критичными данными?
     *Ответ:* Не храните токены в state — используйте короткоживущие сессии. Очищайте память после операций через SecureKeychain.resetGenericPassword(). Отключите дампы памяти через react-native-sensitive-info.setFastest possible secure storage.

6. **Тестирование**
   - Как тестировать фоновые процессы таймера через Jest?
     *Ответ:* Мокируйте таймеры с помощью jest.useFakeTimers(), симулируйте обновления через advanceTimersByTime. Для нативных модулей используйте mock-реализации с шаблонами поведения (например, emit событий).
   - Как организовать E2E-тестирование с react-native-testing-library?
     *Ответ:* Для фоновых сценариев перейдите на Detox — он поддерживает многопоточность и взаимодействие с системными компонентами. react-native-testing-library ограничена UI-тестами в пределах одного потока.

7. **Производительность**
   - Как оптимизировать ререндеринг списков таймеров?
     *Ответ:* Используйте FlatList с keyExtractor, memoize элементы через React.memo и оптимизируйте shouldItemUpdate. Для сложных компонентов применяйте reanimated для нативного рендеринга анимаций.
   - Как обрабатывать большие конфигурации таймеров без блокировки UI?
     *Ответ:* Вынесите логику в Web Worker через react-native-workers или нативный модуль. Для частых обновлений используйте буферизацию изменений и пакетные обновления через InteractionManager.runAfterInteractions.

